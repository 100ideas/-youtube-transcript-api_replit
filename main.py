##########################################
# hello-world example of youtube-transcript-youtube_transcript_api
# https://github.com/jdepoix/youtube-transcript-api#by-example
# 21 aug 2020
#
# 3 sep 2021
#  note - experimenting w/ using autogenerated transcript
#  - needs some formatting work
#  - needs logic to test if human-written transcript available
#  - if not, then use autogen
##########################################


from youtube_transcript_api import YouTubeTranscriptApi
# from youtube_transcript_api.formatters import TextFormatter
# from youtube_transcript_api.formatters import PrettyPrintFormatter
# from youtube_transcript_api.formatters import WebVTTFormatter

import string
import re
import textwrap


# retrieve the available transcripts
transcript_list = YouTubeTranscriptApi.list_transcripts('Gnrh7XOt_84')
# transcript_list = YouTubeTranscriptApi.get_transcripts('jGJT1FRYGcY')
# transcript_list = YouTubeTranscriptApi.get_transcripts('jGJT1FRYGcY', languages=['en'])

# declare var to hold transcript object
fetched = 'NOT_FETCHED'

# iterate over all available transcripts
for transcript in transcript_list:
    # fetch autogenerated transcript:
    # print(transcript.translate('en').fetch())

    if transcript.language_code == 'en':
        # the Transcript object provides metadata properties
        print(
            '[ID]: ' + transcript.video_id,
            '\t[lang]: ' + transcript.language_code,
            # whether it has been manually created or generated by YouTube
            '\t[autogenerated]: ' + str(transcript.is_generated),
            # whether this transcript can be translated or not
            '\t[translatable]: ' + str(transcript.is_translatable),
            # a list of languages the transcript can be translated to
            # transcript.translation_languages,
            '\n\n'
        )
        # short circuit out of loop once we have an english transcript;
        # fetched = transcript.fetch()
        fetched = transcript.translate('en').fetch()
        # print(fetched)
        break

        # for this video, transcript list returns 
        #   [...others, manual english, auto-translated englsh, ...others]
        # so we select manual english by virtue of position in returned list
        #
        # some videos only have autogen english, or no english at all;
        # in the latter case, use the translate api as below

        ## translating the transcript will return another transcript object
        # print(transcript.translate('en').fetch())

        ## you can also directly filter for the language you are looking for, using the transcript list
        ## [note - couldn't get this to work]:
        # transcript = transcript_list.find_transcript(['en'])  



############################################################
# util function from src
# https://github.com/jdepoix/youtube-transcript-api/blob/c5bf0132ffa2906cc1bf6d480a70ef799dedc209/youtube_transcript_api/formatters.py#L84
#
def _seconds_to_timestamp(time):
      """Helper that converts `time` into a transcript cue timestamp.
      :reference: https://www.w3.org/TR/webvtt1/#webvtt-timestamp
      :param time: a float representing time in seconds.
      :type time: float
      :return: a string formatted as a cue timestamp, 'HH:MM:SS.MS'
      :rtype str
      :example:
      >>> self._seconds_to_timestamp(6.93)
      '00:00:06.930'
      """
      time = float(time)
      hours, mins, secs = (
          int(time) // 3600,
          int(time) // 60,
          int(time) % 60,
      )
      ms = int(round((time - int(time))*1000, 2))
      return "{:02d}:{:02d}:{:02d}.{:03d}".format(hours, mins, secs, ms)
############################################################


linewidth = 50
max_lines_per_block = 5 # tbd

# variables for loop inner state
wrapper = textwrap.TextWrapper(width=linewidth, fix_sentence_endings=False, drop_whitespace=False)
length = 0
cap= ''
begin = 0.0
end = 0.0

# accumulate "lines" into short paragraphs of sentences
for line in fetched:
    
    # add text into paragraph 'cap', track timecode
    cap = cap + line['text'] + ' . '
    end += line['duration']
    
    # want paragraphs to end with punctuation, not be too long or short:
    # 
    if (cap.endswith(('.', ':', '!', '?')) or ( (end - begin > 50.0) or ( len(cap) > (linewidth * max_lines_per_block) ) )):
        
        # fix whitespaces errors around punctuation
        cap = re.sub(r'([{}])'.format('.!?:,'),r'\1 ',cap) 
        cap = cap.replace('  ', ' ')
        
        # wrap text into <linewidth>, print
        cap = wrapper.fill(text=cap) + '\n'
        print(_seconds_to_timestamp(begin).rjust(linewidth))
        print(cap)
        
        # reset paragraph accumulator and update timecode position
        cap = ''
        begin = end



############################################################
## play w/ built-in formatters

# pretty = PrettyPrintFormatter().format_transcript(transcript.fetch())
# plain = TextFormatter().format_transcript(fetched)
# vtt = WebVTTFormatter().format_transcript(fetched)

# print(pretty[length], sep='\n')
# print(vtt)
# print(formatted)