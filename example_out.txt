[ID]: jGJT1FRYGcY   [lang]: en  [autogenerated]: False  [translatable]: True 


                                      00:00:00.000
Since I started talking about microservices and
the challenges that you have to solvewhenever you
want to exchange data between your services, I
hear 3 things: First, you only need to model the
scope of your services “the right way” to avoid
these problems.

                                      00:00:15.280
Second, we use multiple local transactions, and
everything works fine.  It’s really not that big
of a deal.  third we have always used distributed
transactions to ensure data consistency.

                                      00:00:26.500
We will keep doing that for our microservice
architecture.  None of these is a good answer to
this problem and will cause lots of problems.  Hi,
I’m Thorben Janssen and in this video,  I will
discuss about Distributed Transactionsand why you
should not use them for Microservices.

                                      00:00:43.120
But before we proceed, if you are new here and
want to learn how to build incredible efficient
persistence layersand handle the challenges of a
microservice architecture, start now by
subscribing and clicking the bell, so you don't
miss anything.

                                      00:00:56.160
Ok, Let’s quickly address the first 2 answers
before we get to the main part of this video.
It’s a popular myththat you can solve all problems
by designing the scope of your services the right
way.

                                      00:01:08.880
That might be the case for highly scalable“hello”
world applications that you see in demos.  But it
doesn’t work that way in the real world.  Don’t
get me wrong; designing the scope of your services
is important, and it makes the implementation of
your application easier.

                                      00:01:24.240
But you will not be able to avoid communication
between your services completely.  You always have
some services that offer their functionality based
on other services.  An example of that is an
OrderInfo service in an online bookstore.

                                      00:01:38.100
It shows the customer the current status of their
orderby the Order service, the Inventory service,
and the Book service.  Another example is an
Inventory service, which needs to reserve a book
for a specific orderand prepare it for delivery
after the Order and the Payment service processed
the order.

                                      00:01:57.700
In these cases, you either: Implement some form of
data exchange between these servicesor move all
the logic to the frontend, which in the end is the
same approach as option oneor Merge all the
services into 1, whichgets you a monolithic
application.

                                      00:02:14.340
As you can see, there are several situations in
which you need to design and implementsome form of
communication and exchange data between your
services.  And that’s OK if you do it
intentionally.

                                      00:02:25.500
There are several patterns and tools for that.  I
explain the most important and popular onesin my
course Data and Communication Patterns for
Microservices.  If teams accepted that they need
to exchange data between their services, quite a
few decide to use multiple, independent, local
transactions.

                                      00:02:43.820
This is a risky decision because sooner or later,
it will cause data inconsistencies.  By using
multiple local transactions, you create a
situation that’s called a dual write.

                                      00:02:55.360
I explained it in great detail in a previous
articleand a video which you will find in the
description and here . To summarize that article,
you can’t handle the situation in which you try to
commit2 independent transactions, and the 2nd
commit fails.

                                      00:03:11.860
You might try to implement workarounds that try to
revert the first transaction.  But you can’t
guarantee that they will always work.  In a
monolithic application or older distributed
applications, we often used transactions that span
over multiple external systems.

                                      00:03:28.480
Typical examples are transactions that include one
or more databasesor a database and a message
broker.  These transactions are called global or
distributed transactions.

                                      00:03:39.120
They enable you to apply the ACID principle to
multiple systems.  Unfortunately, they are not a
good fit for a microservice architecture.  They
use a pattern called 2-phase commit.

                                      00:03:50.400
This pattern describes a complex process that
requires multiple steps and locks.  As you might
have guessed from the name, the main difference
between a localand distributed transaction that
uses the two-phase commit patternis the commit
operation.

                                      00:04:05.960
As soon as more than one system is involved, you
can’t just send a commit message to each of them.
That would create the same problems as we
discussed for dual writes.  The two-phase commit
avoids these problems by splitting the commit into
2 steps:

                                      00:04:21.120
The transaction coordinator first sends a prepare
command to each involved system.  Each system then
checks if they could commit the transaction.  If
that’s the case, they respond with “prepared”and
the transaction coordinator sends a commit command
to all systems.

                                      00:04:36.780
The transaction was successful, and all changes
get committed.  If any of the systems doesn’t
answer the prepare commandor responds with
“failed”, the transaction coordinator sends an
abort command to all systems.

                                      00:04:51.820
This rolls back all the changes performed within
the transaction.  As you can see, a two-phase
commit is more complicated than the simple
commitof a local transaction.

                                      00:05:02.200
But it gets even worse when you take a look at the
systemsthat need to prepare and commit the
transaction.  After a system confirmed the prepare
command, it needs to make sure that it will be
able to commit the transactionwhen it receives the
commit command.

                                      00:05:17.680
That means nothing is allowed to change until that
system gets the commit or abort command.  The only
way to ensure that is to lock all the information
that you changed in the transaction.

                                      00:05:28.220
As long as this lock is active, no other
transaction can use this information.  These locks
can become a bottleneck that slows down your
system and should obviously be avoided.

                                      00:05:38.380
This problem also existed in a distributed,
monolithic application.  But the small scope of a
microservice and the huge number of servicesthat
are often deployed make it worse.

                                      00:05:48.680
A 2-phase commit between a transaction
coordinatorand 2 external systems is already bad
enough.  But the complexity and the performance
impact of the required locksincrease with each
additional external system that takes part in the
transaction.

                                      00:06:03.740
Due to that, a distributed transaction isno longer
an easy to use approach to ensure data
consistencythat, in the worst case, might slow
down your application a little bit.

                                      00:06:13.860
In a microservice architecture, a distributed
transaction is an outdated approach that causes
severe scalability issues.  Modern patterns that
rely on asynchronous data replication or model
distributed write operationsas orchestrated or
choreographed SAGAs avoid these problems.

                                      00:06:30.460
I explain all of them in great detail in my
courseData and Communication Patterns for
Microservices.  OK, that’s it for today.  If you
want to learn more about Hibernate,  you should
join the free Thoughts on Java Library.

                                      00:06:42.840
It gives you free access to a lot of member-only
content like a cheat for this videoand an ebook
about using native queries with JPA and Hibernate.
I’ll add the link to it to the video description
below.

 